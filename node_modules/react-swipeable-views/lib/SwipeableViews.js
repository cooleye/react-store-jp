'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _extends2 = require('babel-runtime/helpers/extends');

var _extends3 = _interopRequireDefault(_extends2);

var _objectWithoutProperties2 = require('babel-runtime/helpers/objectWithoutProperties');

var _objectWithoutProperties3 = _interopRequireDefault(_objectWithoutProperties2);

var _assign = require('babel-runtime/core-js/object/assign');

var _assign2 = _interopRequireDefault(_assign);

var _getPrototypeOf = require('babel-runtime/core-js/object/get-prototype-of');

var _getPrototypeOf2 = _interopRequireDefault(_getPrototypeOf);

var _classCallCheck2 = require('babel-runtime/helpers/classCallCheck');

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _createClass2 = require('babel-runtime/helpers/createClass');

var _createClass3 = _interopRequireDefault(_createClass2);

var _possibleConstructorReturn2 = require('babel-runtime/helpers/possibleConstructorReturn');

var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);

var _inherits2 = require('babel-runtime/helpers/inherits');

var _inherits3 = _interopRequireDefault(_inherits2);

var _react = require('react');

var _react2 = _interopRequireDefault(_react);

var _reactMotion = require('react-motion');

var _warning = require('warning');

var _warning2 = _interopRequireDefault(_warning);

var _constant = require('./constant');

var _checkIndexBounds = require('./utils/checkIndexBounds');

var _checkIndexBounds2 = _interopRequireDefault(_checkIndexBounds);

var _computeIndex2 = require('./utils/computeIndex');

var _computeIndex3 = _interopRequireDefault(_computeIndex2);

var _getDisplaySameSlide = require('./utils/getDisplaySameSlide');

var _getDisplaySameSlide2 = _interopRequireDefault(_getDisplaySameSlide);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var styles = {
  container: {
    display: 'flex',
    willChange: 'transform'
  },
  slide: {
    width: '100%',
    flexShrink: 0,
    overflow: 'auto'
  }
}; /* eslint-disable flowtype/require-valid-file-annotation */

var axisProperties = {
  root: {
    x: {
      overflowX: 'hidden'
    },
    'x-reverse': {
      overflowX: 'hidden'
    },
    y: {
      overflowY: 'hidden'
    },
    'y-reverse': {
      overflowY: 'hidden'
    }
  },
  flexDirection: {
    x: 'row',
    'x-reverse': 'row-reverse',
    y: 'column',
    'y-reverse': 'column-reverse'
  },
  transform: {
    x: function x(translate) {
      return 'translate(' + -translate + '%, 0)';
    },
    'x-reverse': function xReverse(translate) {
      return 'translate(' + translate + '%, 0)';
    },
    y: function y(translate) {
      return 'translate(0, ' + -translate + '%)';
    },
    'y-reverse': function yReverse(translate) {
      return 'translate(0, ' + translate + '%)';
    }
  },
  length: {
    x: 'width',
    'x-reverse': 'width',
    y: 'height',
    'y-reverse': 'height'
  },
  rotationMatrix: {
    x: {
      x: [1, 0],
      y: [0, 1]
    },
    'x-reverse': {
      x: [-1, 0],
      y: [0, 1]
    },
    y: {
      x: [0, 1],
      y: [1, 0]
    },
    'y-reverse': {
      x: [0, -1],
      y: [1, 0]
    }
  }
};

// We are using a 2x2 rotation matrix.
function applyRotationMatrix(touch, axis) {
  var rotationMatrix = axisProperties.rotationMatrix[axis];

  return {
    pageX: rotationMatrix.x[0] * touch.pageX + rotationMatrix.x[1] * touch.pageY,
    pageY: rotationMatrix.y[0] * touch.pageX + rotationMatrix.y[1] * touch.pageY
  };
}

function getDomTreeShapes(element, rootNode) {
  var domTreeShapes = [];

  while (element && element !== rootNode.firstChild) {
    // Ignore the nodes that have no width.
    if (element.clientWidth > 0) {
      domTreeShapes.push({
        element: element,
        scrollWidth: element.scrollWidth,
        clientWidth: element.clientWidth,
        scrollLeft: element.scrollLeft
      });
    }

    element = element.parentNode;
  }

  return domTreeShapes.slice(0, -2) // Remove internal elements.
  .filter(function (shape) {
    return shape.scrollWidth > shape.clientWidth;
  }); // Keep elements with a scroll.
}

// We can only have one node at the time claiming ownership for handling the swipe.
// Otherwise, the UX would be confusing.
var nodeHowClaimedTheScroll = null;

var SwipeableViews = function (_Component) {
  (0, _inherits3.default)(SwipeableViews, _Component);

  function SwipeableViews() {
    var _ref;

    var _temp, _this, _ret;

    (0, _classCallCheck3.default)(this, SwipeableViews);

    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    return _ret = (_temp = (_this = (0, _possibleConstructorReturn3.default)(this, (_ref = SwipeableViews.__proto__ || (0, _getPrototypeOf2.default)(SwipeableViews)).call.apply(_ref, [this].concat(args))), _this), _this.state = {}, _this.viewLength = 0, _this.startX = 0, _this.lastX = 0, _this.vx = 0, _this.startY = 0, _this.isSwiping = undefined, _this.started = false, _this.handleTouchStart = function (event) {
      var _this$props = _this.props;
      var axis = _this$props.axis;
      var onTouchStart = _this$props.onTouchStart;


      if (onTouchStart) {
        onTouchStart(event);
      }

      var touch = applyRotationMatrix(event.touches[0], axis);

      _this.viewLength = _this.node.getBoundingClientRect()[axisProperties.length[axis]];
      _this.startX = touch.pageX;
      _this.lastX = touch.pageX;
      _this.vx = 0;
      _this.startY = touch.pageY;
      _this.isSwiping = undefined;
      _this.started = true;
    }, _this.handleTouchMove = function (event) {
      if (_this.props.onTouchMove) {
        _this.props.onTouchMove(event);
      }

      // The touch start event can be cancel.
      // Makes sure we set a starting point.
      if (!_this.started) {
        _this.handleTouchStart(event);
        return;
      }

      // We are not supposed to hanlde this touch move.
      if (nodeHowClaimedTheScroll !== null && nodeHowClaimedTheScroll !== _this.node) {
        return;
      }

      var _this$props2 = _this.props;
      var axis = _this$props2.axis;
      var children = _this$props2.children;
      var onSwitching = _this$props2.onSwitching;
      var resistance = _this$props2.resistance;


      var touch = applyRotationMatrix(event.touches[0], axis);

      // We don't know yet.
      if (_this.isSwiping === undefined) {
        var dx = Math.abs(_this.startX - touch.pageX);
        var dy = Math.abs(_this.startY - touch.pageY);

        var isSwiping = dx > dy && dx > _constant.UNCERTAINTY_THRESHOLD;

        // We are likely to be swiping, let's prevent the scroll event.
        if (dx > dy) {
          event.preventDefault();
        }

        if (isSwiping === true || dy > _constant.UNCERTAINTY_THRESHOLD) {
          _this.isSwiping = isSwiping;
          _this.startX = touch.pageX; // Shift the starting point.

          return; // Let's wait the next touch event to move something.
        }
      }

      if (_this.isSwiping !== true) {
        return;
      }

      // We are swiping, let's prevent the scroll event.
      event.preventDefault();

      // Low Pass filter.
      _this.vx = _this.vx * 0.5 + (touch.pageX - _this.lastX) * 0.5;
      _this.lastX = touch.pageX;

      var _computeIndex = (0, _computeIndex3.default)({
        children: children,
        resistance: resistance,
        pageX: touch.pageX,
        indexLatest: _this.state.indexLatest,
        startX: _this.startX,
        viewLength: _this.viewLength
      });

      var index = _computeIndex.index;
      var startX = _computeIndex.startX;

      // Add support for native scroll elements.

      if (nodeHowClaimedTheScroll === null) {
        var domTreeShapes = getDomTreeShapes(event.target, _this.node);

        var hasFoundNativeHandler = domTreeShapes.some(function (shape) {
          if (index >= _this.state.indexCurrent && shape.scrollLeft + shape.clientWidth < shape.scrollWidth || index <= _this.state.indexCurrent && shape.scrollLeft > 0) {
            nodeHowClaimedTheScroll = shape.element;
            return true;
          }

          return false;
        });

        // We abort the touch move handler.
        if (hasFoundNativeHandler) {
          return;
        }
      }

      // We are moving toward the edges.
      if (startX) {
        _this.startX = startX;
      } else if (nodeHowClaimedTheScroll === null) {
        nodeHowClaimedTheScroll = _this.node;
      }

      _this.setState({
        isDragging: true,
        indexCurrent: index
      }, function () {
        if (onSwitching) {
          onSwitching(index, 'move');
        }
      });
    }, _this.handleTouchEnd = function (event) {
      if (_this.props.onTouchEnd) {
        _this.props.onTouchEnd(event);
      }

      nodeHowClaimedTheScroll = null;

      // The touch start event can be cancel.
      // Makes sure that a starting point is set.
      if (!_this.started) {
        return;
      }

      _this.started = false;

      if (_this.isSwiping !== true) {
        return;
      }

      var indexLatest = _this.state.indexLatest;
      var indexCurrent = _this.state.indexCurrent;

      var indexNew = void 0;

      // Quick movement
      if (Math.abs(_this.vx) > _this.props.threshold) {
        if (_this.vx > 0) {
          indexNew = Math.floor(indexCurrent);
        } else {
          indexNew = Math.ceil(indexCurrent);
        }
      } else if (Math.abs(indexLatest - indexCurrent) > 0.6) {
        // Some hysteresis with indexLatest
        indexNew = Math.round(indexCurrent);
      } else {
        indexNew = indexLatest;
      }

      var indexMax = _react.Children.count(_this.props.children) - 1;

      if (indexNew < 0) {
        indexNew = 0;
      } else if (indexNew > indexMax) {
        indexNew = indexMax;
      }

      _this.setState({
        indexCurrent: indexNew,
        indexLatest: indexNew,
        isDragging: false,
        displaySameSlide: false
      }, function () {
        if (_this.props.onSwitching) {
          _this.props.onSwitching(indexNew, 'end');
        }

        if (_this.props.onChangeIndex && indexNew !== indexLatest) {
          _this.props.onChangeIndex(indexNew, indexLatest);
        }
      });
    }, _temp), (0, _possibleConstructorReturn3.default)(_this, _ret);
  }

  (0, _createClass3.default)(SwipeableViews, [{
    key: 'componentWillMount',
    value: function componentWillMount() {
      if (process.env.NODE_ENV !== 'production') {
        (0, _checkIndexBounds2.default)(this.props);
      }

      this.setState({
        indexCurrent: this.props.index,
        indexLatest: this.props.index,
        isDragging: false,
        isFirstRender: true,
        heightLatest: 0
      });
    }
  }, {
    key: 'componentDidMount',
    value: function componentDidMount() {
      /* eslint-disable react/no-did-mount-set-state */
      this.setState({
        isFirstRender: false
      });
      /* eslint-enable react/no-did-mount-set-state */
    }
  }, {
    key: 'componentWillReceiveProps',
    value: function componentWillReceiveProps(nextProps) {
      var index = nextProps.index;


      if (typeof index === 'number' && index !== this.props.index) {
        if (process.env.NODE_ENV !== 'production') {
          (0, _checkIndexBounds2.default)(nextProps);
        }

        this.setState({
          indexCurrent: index,
          indexLatest: index,
          // If true, we are going to display the same slide. We shoudn't animate it.
          displaySameSlide: (0, _getDisplaySameSlide2.default)(this.props, nextProps)
        });
      }
    }
  }, {
    key: 'updateHeight',
    value: function updateHeight(node) {
      if (node !== null) {
        var child = node.children[0];
        if (child !== undefined && child.offsetHeight !== undefined && this.state.heightLatest !== child.offsetHeight) {
          this.setState({
            heightLatest: child.offsetHeight
          });
        }
      }
    }
  }, {
    key: 'renderContainer',
    value: function renderContainer(interpolatedStyle, animateHeight, childrenToRender) {
      var _props = this.props;
      var axis = _props.axis;
      var containerStyle = _props.containerStyle;


      var transform = axisProperties.transform[axis](interpolatedStyle.translate);

      var styleNew = {
        WebkitTransform: transform,
        transform: transform,
        height: null,
        flexDirection: axisProperties.flexDirection[axis]
      };

      if (animateHeight) {
        styleNew.height = interpolatedStyle.height;
      }

      return _react2.default.createElement(
        'div',
        { style: (0, _assign2.default)({}, styleNew, styles.container, containerStyle) },
        childrenToRender
      );
    }
  }, {
    key: 'render',
    value: function render() {
      var _this2 = this;

      var _props2 = this.props;
      var animateHeight = _props2.animateHeight;
      var animateTransitions = _props2.animateTransitions;
      var axis = _props2.axis;
      var children = _props2.children;
      var containerStyle = _props2.containerStyle;
      var disabled = _props2.disabled;
      var index = _props2.index;
      var onChangeIndex = _props2.onChangeIndex;
      var onSwitching = _props2.onSwitching;
      var resistance = _props2.resistance;
      var slideStyle = _props2.slideStyle;
      var springConfig = _props2.springConfig;
      var style = _props2.style;
      var threshold = _props2.threshold;
      var other = (0, _objectWithoutProperties3.default)(_props2, ['animateHeight', 'animateTransitions', 'axis', 'children', 'containerStyle', 'disabled', 'index', 'onChangeIndex', 'onSwitching', 'resistance', 'slideStyle', 'springConfig', 'style', 'threshold']);
      var _state = this.state;
      var displaySameSlide = _state.displaySameSlide;
      var heightLatest = _state.heightLatest;
      var indexCurrent = _state.indexCurrent;
      var isDragging = _state.isDragging;
      var isFirstRender = _state.isFirstRender;


      var translate = indexCurrent * 100;
      var height = heightLatest;

      var motionStyle = isDragging || !animateTransitions || displaySameSlide ? {
        translate: translate,
        height: height
      } : {
        translate: (0, _reactMotion.spring)(translate, springConfig),
        height: height !== 0 ? (0, _reactMotion.spring)(height, springConfig) : 0
      };

      var touchEvents = disabled ? {} : {
        onTouchStart: this.handleTouchStart,
        onTouchMove: this.handleTouchMove,
        onTouchEnd: this.handleTouchEnd
      };

      // There is no point to animate if we are already providing a height.
      process.env.NODE_ENV !== "production" ? (0, _warning2.default)(!animateHeight || !containerStyle || !containerStyle.height && !containerStyle.maxHeight && !containerStyle.minHeight, 'react-swipeable-view: You are setting animateHeight to true but you are also providing a custom height.\n      The custom height has a higher priority than the animateHeight property.\n      So animateHeight is most likely having no effect at all.') : void 0;

      var slideStyleObj = (0, _assign2.default)({}, styles.slide, slideStyle);

      var childrenToRender = _react.Children.map(children, function (child, indexChild) {
        if (isFirstRender && indexChild > 0) {
          return null;
        }

        var ref = void 0;

        if (animateHeight && indexChild === _this2.state.indexLatest) {
          ref = function ref(node) {
            return _this2.updateHeight(node);
          };
          slideStyleObj.overflowY = 'hidden';
        }

        return _react2.default.createElement(
          'div',
          { ref: ref, style: slideStyleObj },
          child
        );
      });

      return _react2.default.createElement(
        'div',
        (0, _extends3.default)({
          ref: function ref(node) {
            _this2.node = node;
          },
          style: (0, _assign2.default)({}, axisProperties.root[axis], style)
        }, other, touchEvents),
        _react2.default.createElement(
          _reactMotion.Motion,
          { style: motionStyle, onRest: this.props.onTransitionEnd },
          function (interpolatedStyle) {
            return _this2.renderContainer(interpolatedStyle, animateHeight, childrenToRender);
          }
        )
      );
    }
  }]);
  return SwipeableViews;
}(_react.Component);

SwipeableViews.defaultProps = {
  animateHeight: false,
  animateTransitions: true,
  axis: 'x',
  index: 0,
  threshold: 5,
  resistance: false,
  disabled: false,
  springConfig: {
    stiffness: 300,
    damping: 30
  }
};
process.env.NODE_ENV !== "production" ? SwipeableViews.propTypes = {
  /**
   * If `true`, the height of the container will be animated to match the current slide height.
   * Animating another style property has a negative impact regarding performance.
   */
  animateHeight: _react.PropTypes.bool,
  /**
   * If `false`, changes to the index prop will not cause an animated transition.
   */
  animateTransitions: _react.PropTypes.bool,
  /**
   * The axis on which the slides will slide.
   */
  axis: _react.PropTypes.oneOf(['x', 'x-reverse', 'y', 'y-reverse']),
  /**
   * Use this property to provide your slides.
   */
  children: _react.PropTypes.node.isRequired,
  /**
   * This is the inlined style that will be applied
   * to each slide container.
   */
  containerStyle: _react.PropTypes.object,
  /**
   * If `true`, it will disable touch events.
   * This is useful when you want to prohibit the user from changing slides.
   */
  disabled: _react.PropTypes.bool,
  /**
   * This is the index of the slide to show.
   * This is useful when you want to change the default slide shown.
   * Or when you have tabs linked to each slide.
   */
  index: _react.PropTypes.number,
  /**
   * This is callback prop. It's call by the
   * component when the shown slide change after a swipe made by the user.
   * This is useful when you have tabs linked to each slide.
   *
   * @param {integer} index This is the current index of the slide.
   * @param {integer} indexLatest This is the oldest index of the slide.
   */
  onChangeIndex: _react.PropTypes.func,
  /**
   * This is callback prop. It's called by the
   * component when the slide switching.
   * This is useful when you want to implement something corresponding to the current slide position.
   *
   * @param {integer} index This is the current index of the slide.
   * @param {string} type Can be either `move` or `end`.
   */
  onSwitching: _react.PropTypes.func,
  /**
   * @ignore
   */
  onTouchEnd: _react.PropTypes.func,
  /**
   * @ignore
   */
  onTouchMove: _react.PropTypes.func,
  /**
   * @ignore
   */
  onTouchStart: _react.PropTypes.func,
  /**
   * The callback that fires when the animation comes to a rest.
   * This is useful to defer CPU intensive task.
   */
  onTransitionEnd: _react.PropTypes.func,
  /**
   * If `true`, it will add bounds effect on the edges.
   */
  resistance: _react.PropTypes.bool,
  /**
   * This is the inlined style that will be applied
   * on the slide component.
   */
  slideStyle: _react.PropTypes.object,
  /**
   * This is the config given to react-motion for the spring.
   * This is useful to change the dynamic of the transition.
   */
  springConfig: _react.PropTypes.object,
  /**
   * This is the inlined style that will be applied
   * on the root component.
   */
  style: _react.PropTypes.object,
  /**
   * This is the threshold used for detecting a quick swipe.
   * If the computed speed is above this value, the index change.
   */
  threshold: _react.PropTypes.number
} : void 0;
exports.default = SwipeableViews;